"use strict";

const Debug = require('debug');

const rlcDesc = require('rlc-faucet-contract/build/contracts/RLC.json');

const erlcDesc = require('@iexec/erlc/build/contracts-min/ERLCTokenSwap.json');

const {
  Contract
} = require('ethers');

const pocoVersion = require('@iexec/poco/package.json').version;

const iexecTokenDesc = require('@iexec/poco/build/contracts-min/IexecInterfaceToken.json');

const iexecNativeDesc = require('@iexec/poco/build/contracts-min/IexecInterfaceNative.json');

const appRegistryDesc = require('@iexec/poco/build/contracts-min/AppRegistry.json');

const workerpoolRegistryDesc = require('@iexec/poco/build/contracts-min/WorkerpoolRegistry.json');

const datasetRegistryDesc = require('@iexec/poco/build/contracts-min/DatasetRegistry.json');

const appDesc = require('@iexec/poco/build/contracts-min/App.json');

const workerpoolDesc = require('@iexec/poco/build/contracts-min/Workerpool.json');

const datasetDesc = require('@iexec/poco/build/contracts-min/Dataset.json');

const utils = require('./utils');

const debug = Debug('iexec-contracts-js-client:hub');

const getRlcDesc = (isNative, flavour) => {
  if (isNative) {
    return undefined;
  }

  if (flavour === 'enterprise') {
    return erlcDesc;
  }

  return rlcDesc;
};

const getHubDescMap = (isNative, flavour) => ({
  hub: {
    contractDesc: isNative ? iexecNativeDesc : iexecTokenDesc
  },
  clerk: {
    contractDesc: isNative ? iexecNativeDesc : iexecTokenDesc
  },
  rlc: {
    contractDesc: getRlcDesc(isNative, flavour),
    hubPropName: 'token'
  },
  app: {
    contractDesc: appDesc,
    createParams: ['owner', 'name', 'type', 'multiaddr', 'checksum', 'mrenclave'],
    registryName: 'appRegistry'
  },
  appRegistry: {
    contractDesc: appRegistryDesc,
    hubPropName: 'appregistry'
  },
  dataset: {
    contractDesc: datasetDesc,
    createParams: ['owner', 'name', 'multiaddr', 'checksum'],
    registryName: 'datasetRegistry'
  },
  datasetRegistry: {
    contractDesc: datasetRegistryDesc,
    hubPropName: 'datasetregistry'
  },
  workerpool: {
    contractDesc: workerpoolDesc,
    createParams: ['owner', 'description'],
    registryName: 'workerpoolRegistry'
  },
  workerpoolRegistry: {
    contractDesc: workerpoolRegistryDesc,
    hubPropName: 'workerpoolregistry'
  }
});

const createHub = ({
  ethSigner,
  ethProvider,
  chainId,
  globalHubAddress,
  isNative,
  flavour,
  gasPrice,
  confirms
}) => {
  debug('chainId', chainId, 'isNative', isNative, 'flavour', flavour);
  const hubDescMap = getHubDescMap(isNative, flavour);
  const hubAddress = globalHubAddress || utils.getContractAddress('hub', hubDescMap.hub.contractDesc, chainId, flavour, {
    strict: true
  });
  debug('hubAddress', hubAddress);

  const getContract = objName => ({
    at
  } = {}) => {
    try {
      debug(`getContract() ${objName} at`, at);
      const {
        contractDesc
      } = hubDescMap[objName];
      const atAddress = at || utils.getContractAddress(objName, contractDesc, chainId, flavour, {
        strict: false
      });
      debug('getContract() atAddress', atAddress);

      if (!atAddress) {
        throw Error(`no contract address provided, and no existing contract address on chain ${chainId}`);
      }

      const contract = new Contract(atAddress, contractDesc.abi, ethSigner || ethProvider);
      return contract;
    } catch (error) {
      debug('getContract()', error);
      throw error;
    }
  };

  const getIExecContract = ({
    at = hubAddress
  } = {}) => getContract('hub')({
    at
  });

  const getHubContract = getIExecContract;
  const getClerkContract = getIExecContract;
  const getRLCContract = getContract('rlc');
  const getAppContract = getContract('app');
  const getDatasetContract = getContract('dataset');
  const getWorkerpoolContract = getContract('workerpool');
  const getAppRegistryContract = getContract('appRegistry');
  const getDatasetRegistryContract = getContract('datasetRegistry');
  const getWorkerpoolRegistryContract = getContract('workerpoolRegistry');

  const fetchContractAddress = objName => async ({
    strict = true,
    hub = hubAddress
  } = {}) => {
    const {
      contractDesc,
      hubPropName
    } = hubDescMap[objName];

    if (!hub && strict) {
      throw Error(`Hub address missing but needed to fetch ${objName} address`);
    }

    if (!hub) return undefined;

    if (!hubPropName) {
      return hub;
    }

    const defaultHubAddress = utils.getContractAddress('hub', hubDescMap.hub.contractDesc, chainId, flavour, {
      strict: false
    });

    if (hub === defaultHubAddress) {
      const contractAddress = utils.getContractAddress(objName, contractDesc, chainId, flavour, {
        strict: false
      });
      if (contractAddress) return contractAddress;
    }

    const fetchedContractAddress = await getHubContract({
      at: hub
    })[hubPropName]();
    debug(`fetchedContractAddress ${objName}`, fetchedContractAddress);
    return fetchedContractAddress;
  };

  const fetchIExecAddress = fetchContractAddress('hub');
  const fetchHubAddress = fetchIExecAddress;
  const fetchClerkAddress = fetchIExecAddress;
  const fetchRLCAddress = fetchContractAddress('rlc');
  const fetchAppRegistryAddress = fetchContractAddress('appRegistry');
  const fetchDatasetRegistryAddress = fetchContractAddress('datasetRegistry');
  const fetchWorkerpoolRegistryAddress = fetchContractAddress('workerpoolRegistry');

  const checkDeployedObj = objName => async (address, {
    strict = true,
    hub = hubAddress
  } = {}) => {
    const hubContract = getHubContract({
      at: hub
    });
    const regisrtyHubName = hubDescMap[hubDescMap[objName].registryName].hubPropName;
    const registryAddress = await hubContract[regisrtyHubName]();
    const registryContract = getContract(hubDescMap[objName].registryName)({
      at: registryAddress
    });
    const isRegistered = await registryContract.isRegistered(address);
    debug('isRegistered', isRegistered);
    if (isRegistered) return true;

    if (strict) {
      throw new Error(`No ${objName} contract deployed at address ${address}`);
    }

    return false;
  };

  const checkDeployedApp = checkDeployedObj('app');
  const checkDeployedDataset = checkDeployedObj('dataset');
  const checkDeployedWorkerpool = checkDeployedObj('workerpool');

  const createObj = objName => async (obj, {
    hub = hubAddress
  } = {}) => {
    try {
      debug('hub', hub);

      if (!hub) {
        throw Error(`no hub address provided, and no existing hub contract on chain ${chainId}`);
      }

      debug('obj', obj);
      const hubContract = getHubContract({
        at: hub
      });
      const regisrtyHubName = hubDescMap[hubDescMap[objName].registryName].hubPropName;
      const registryAddress = await hubContract[regisrtyHubName]();
      debug('registryAddress', registryAddress);
      const registryContract = getContract(hubDescMap[objName].registryName)({
        at: registryAddress
      });
      const args = hubDescMap[objName].createParams.map(e => obj[e]);
      debug('args', args);
      const predictFonctionName = 'predict'.concat(utils.toUpperFirst(objName));
      debug('predictFonctionName', predictFonctionName);
      const predictedAddress = await registryContract[predictFonctionName](...args);
      debug('predictedAddress', predictedAddress);
      const isDeployed = await checkDeployedObj(objName)(predictedAddress, {
        strict: false
      });

      if (isDeployed) {
        throw Error(`${utils.toUpperFirst(objName)} already deployed at address ${predictedAddress}`);
      }

      const createFonctionName = 'create'.concat(utils.toUpperFirst(objName));
      const tx = await registryContract[createFonctionName](...args, {
        gasPrice
      });
      const txReceipt = await tx.wait(confirms);
      return txReceipt;
    } catch (error) {
      debug('createObj()', error);
      throw error;
    }
  };

  const createApp = createObj('app');
  const createDataset = createObj('dataset');
  const createWorkerpool = createObj('workerpool');

  const getObjProps = objName => async at => {
    try {
      debug('at', at);
      const {
        contractDesc
      } = hubDescMap[objName];
      const objAddress = at || utils.getContractAddress(objName, contractDesc, chainId, flavour, {
        strict: false
      });

      if (!objAddress) {
        throw Error(`no contract address provided, and no existing contract on chain ${chainId}`);
      }

      const objContract = new Contract(objAddress, contractDesc.abi, ethProvider);
      const objPropNames = contractDesc.abi.filter(e => e.stateMutability === 'view' && e.inputs.length === 0).map(e => e.name);
      debug('objPropNames', objPropNames);
      const objPropsRPC = await Promise.all(objPropNames.map(e => objContract[e]()));
      debug('objPropsRPC', objPropsRPC);
      const objProps = objPropsRPC.reduce((accu, curr, i) => Object.assign(accu, {
        [objPropNames[i]]: curr
      }), {});
      debug('objProps', objProps);
      return objProps;
    } catch (error) {
      debug('getObjProps()', error);
      throw error;
    }
  };

  const getHubProps = getObjProps('hub');
  const getAppProps = getObjProps('app');
  const getDatasetProps = getObjProps('dataset');
  const getWorkerpoolProps = getObjProps('workerpool');

  const getUserObjCount = objName => async (userAddress, {
    hub = hubAddress
  } = {}) => {
    try {
      debug('hub', hub);

      if (!hub) {
        throw Error(`no hub address provided, and no existing hub contract on chain ${chainId}`);
      }

      const hubContract = getHubContract({
        at: hub
      });
      const registryAddress = await hubContract[hubDescMap[hubDescMap[objName].registryName].hubPropName]();
      debug('registryAddress', registryAddress);
      const registryContract = getContract(hubDescMap[objName].registryName)({
        at: registryAddress
      });
      const objsCountBN = await registryContract.balanceOf(userAddress);
      debug('objsCountBN', objsCountBN);
      return objsCountBN;
    } catch (error) {
      debug('getUserObjCount()', error);
      throw error;
    }
  };

  const getUserAppCount = getUserObjCount('app');
  const getUserDatasetCount = getUserObjCount('dataset');
  const getUserWorkerpoolCount = getUserObjCount('workerpool');

  const createCategory = async (category, {
    hub = hubAddress
  } = {}) => {
    try {
      debug('hub', hub);
      const hubContract = getHubContract({
        at: hub
      });
      const categoryOwner = await hubContract.owner();
      debug('categoryOwner', categoryOwner);
      const userAddress = await ethSigner.getAddress();
      debug('userAddress', userAddress);

      if (!(categoryOwner === userAddress)) {
        throw Error(`only category owner ${categoryOwner} can create new categories`);
      }

      const args = [category.name, category.description, category.workClockTimeRef];
      const tx = await hubContract.createCategory(...args, {
        gasPrice
      });
      const txReceipt = await tx.wait(confirms);
      return txReceipt;
    } catch (error) {
      debug('createCategory()', error);
      throw error;
    }
  };

  const getCategoryByIndex = async (index, {
    hub = hubAddress
  } = {}) => {
    try {
      debug('hub', hub);
      const hubContract = getHubContract({
        at: hub
      });
      const categoryRPC = await hubContract.viewCategory(index);
      debug('categoryRPC', categoryRPC);
      const categoryPropNames = ['name', 'description', 'workClockTimeRef'];
      const category = categoryRPC.reduce((accu, curr, i) => Object.assign(accu, {
        [categoryPropNames[i]]: curr
      }), {});
      return category;
    } catch (error) {
      debug('getCategoryByIndex()', error);
      throw error;
    }
  };

  const checkBalance = async (userAddress, {
    hub = hubAddress
  } = {}) => {
    try {
      debug('hub', hub);
      debug('userAddress', userAddress);

      if (!hub) {
        throw Error(`no hub address provided, and no existing hub contract on chain ${chainId}`);
      }

      const clerkContract = getHubContract({
        at: hub
      });
      const balancesRPC = await clerkContract.viewAccount(userAddress);
      debug('balancesRPC', balancesRPC);
      return balancesRPC;
    } catch (error) {
      debug('checkBalance()', error);
      throw error;
    }
  };

  const getUserObjIdByIndex = objName => async (userAddress, index, {
    hub = hubAddress
  } = {}) => {
    try {
      debug('hub', hub);

      if (!hub) {
        throw Error(`no hub address provided, and no existing hub contract on chain ${chainId}`);
      }

      const hubContract = getHubContract({
        at: hub
      });
      const registryAddress = await hubContract[hubDescMap[hubDescMap[objName].registryName].hubPropName]();
      debug('registryAddress', registryAddress);
      const registryContract = getContract(hubDescMap[objName].registryName)({
        at: registryAddress
      });
      const objAddress = await registryContract.tokenOfOwnerByIndex(userAddress, index);
      return objAddress;
    } catch (error) {
      debug('getUserObjIdByIndex()', error);
      throw error;
    }
  };

  const getUserAppIdByIndex = getUserObjIdByIndex('app');
  const getUserDatasetIdByIndex = getUserObjIdByIndex('dataset');
  const getUserWorkerpoolIdByIndex = getUserObjIdByIndex('workerpool');
  return {
    pocoVersion,
    isNative,
    flavour,
    hubAddress,
    checkBalance,
    getContract,
    getIExecContract,
    getHubContract,
    getClerkContract,
    getAppContract,
    getAppRegistryContract,
    getDatasetContract,
    getDatasetRegistryContract,
    getWorkerpoolContract,
    getWorkerpoolRegistryContract,
    ...(!isNative && {
      getRLCContract
    }),
    ...(!isNative && {
      fetchRLCAddress
    }),
    fetchIExecAddress,
    fetchHubAddress,
    fetchClerkAddress,
    fetchAppRegistryAddress,
    fetchDatasetRegistryAddress,
    fetchWorkerpoolRegistryAddress,
    createObj,
    createApp,
    createDataset,
    createWorkerpool,
    createCategory,
    getObjProps,
    getHubProps,
    getAppProps,
    getDatasetProps,
    getWorkerpoolProps,
    getCategoryByIndex,
    getUserObjIdByIndex,
    getUserAppIdByIndex,
    getUserDatasetIdByIndex,
    getUserWorkerpoolIdByIndex,
    getUserObjCount,
    getUserAppCount,
    getUserDatasetCount,
    getUserWorkerpoolCount,
    checkDeployedObj,
    checkDeployedApp,
    checkDeployedDataset,
    checkDeployedWorkerpool
  };
};

module.exports = createHub;